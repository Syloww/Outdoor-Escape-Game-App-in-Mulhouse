<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>PrÃ©cision Verre - Jeu de Remplissage</title>
    <link rel="stylesheet" href="styles/sacha.css">
</head>

<body>
    <div class="background-container">
        <picture>
            <source media="(max-width: 1024px)" srcset="
                    images/._2025_11_47_07_w87eeo_c_scale,w_200.png 200w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_335.png 335w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_442.png 442w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_524.png 524w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_541.png 541w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_737.png 737w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_749.png 749w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_779.png 779w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_839.png 839w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_866.png 866w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_853.png 853w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_966.png 966w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_987.png 987w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_1019.png 1019w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_1023.png 1023w,
                    images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_1024.png 1024w">
            <img sizes="100vw" srcset="
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_200.png 200w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_335.png 335w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_442.png 442w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_524.png 524w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_541.png 541w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_737.png 737w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_749.png 749w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_779.png 779w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_839.png 839w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_866.png 866w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_853.png 853w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_966.png 966w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_987.png 987w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_1019.png 1019w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_1023.png 1023w,
                images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_1024.png 1024w"
                src="images/ChatGPT_Image_2_avr._2025_11_47_07_w87eeo_c_scale,w_1024.png" alt="Background image">
        </picture>
    </div>
    <div class="landscape-warning">
        <h2>Rotation required</h2>
        <p>Please keep your device in portrait mode to play and disable automatic rotation.</p>
    </div>

    <div class="info-panel">
        <div class="info-item">
            <div>Level</div>
            <span id="level">1</span>
        </div>
        <div class="info-item">
            <div>Score</div>
            <span id="score">0</span>
        </div>
        <div class="info-item">
            <div>Goal</div>
            <span id="target">0%</span>
        </div>
    </div>

    <div class="progress-container">
        <div id="progressBar" class="progress-bar">0/1000</div>
    </div>

    <div class="game-container">
        <div id="sourceBottle" class="bottle">
            <div id="sourceBeer" class="beer" style="height: 100%;">
                <div class="beer-surface"></div>
            </div>
        </div>
        <div id="targetGlass" class="glass">
            <div id="targetRange" class="target-range"></div>
            <div id="targetLine" class="target-line"></div>
            <div id="targetBeer" class="beer" style="height: 0%;">
                <div class="beer-surface"></div>
            </div>
        </div>
    </div>

    <div class="buttons-right">
        <button id="validateBtn">Confirm</button>
        <button id="restartBtn">Replay</button>
        <button id="resetBtn">Reset</button>
    </div>

    <div class="level-complete">
        <h2>Succesful !</h2>
        <p>Precision: <span id="precisionValue">0</span>%</p>
        <div class="precision-meter">
            <div id="precisionFill" class="precision-fill"></div>
        </div>
        <p>Score: <span id="finalScore">0</span></p>
        <button id="continueBtn">Continue</button>
    </div>

    <div class="level-fail">
        <h2>Missed !</h2>
        <p>Goal: <span id="targetLimit">0</span>%</p>
        <p>Filling: <span id="actualFill">0</span>%</p>
        <p>Precision: <span id="failPrecision">0</span>%</p>
        <p>Points lost: <span id="pointsLost">0</span></p>
        <button id="retryBtn">Retry </button>
    </div>

    <div class="game-over">
        <h2>Congratulation !</h2>
        <p>Objective achieved !</p>
        <p>Final Score: <span id="finalTotalScore">0</span></p>
        <p>Level: <span id="totalLevels">0</span></p>
        <button onclick="window.location.href='dialogue.html?continueFrom=8'">Continue Story</button>        </div>
    </div>

    <div class="tutorial">
        <h2>Glass precision</h2>
        <p>Tilt your phone to the right to pour the beer.</p>
        <div class="tilt-indicator">
            <div class="tilt-handle"></div>
        </div>
        <p>Reach to the green line without going over !</p>
        <p>A sound signal will alert you when you are close to the goal.</p>
        <p>Goal: 1000 points.</p>
        <button id="startBtn">Start</button>
    </div>
    <button class="voice-btn" aria-label="Lire le contenu de la page">ðŸ”Š</button>




    <script>
        // Ã‰lÃ©ments du DOM
        const sourceBottle = document.getElementById('sourceBottle');
        const targetGlass = document.getElementById('targetGlass');
        const sourceBeer = document.getElementById('sourceBeer');
        const targetBeer = document.getElementById('targetBeer');
        const targetLine = document.getElementById('targetLine');
        const targetRange = document.getElementById('targetRange');
        const levelDisplay = document.getElementById('level');
        const scoreDisplay = document.getElementById('score');
        const targetDisplay = document.getElementById('target');
        const restartBtn = document.getElementById('restartBtn');
        const resetBtn = document.getElementById('resetBtn');
        const levelCompleteScreen = document.querySelector('.level-complete');
        const levelFailScreen = document.querySelector('.level-fail');
        const finalScoreDisplay = document.getElementById('finalScore');
        const precisionValue = document.getElementById('precisionValue');
        const precisionFill = document.getElementById('precisionFill');
        const continueBtn = document.getElementById('continueBtn');
        const retryBtn = document.getElementById('retryBtn');
        const targetLimitDisplay = document.getElementById('targetLimit');
        const actualFillDisplay = document.getElementById('actualFill');
        const tutorialScreen = document.querySelector('.tutorial');
        const startBtn = document.getElementById('startBtn');
        const validateBtn = document.getElementById('validateBtn');
        const tiltHandle = document.querySelector('.tilt-handle');
        const progressBar = document.getElementById('progressBar');
        const gameOverScreen = document.querySelector('.game-over');
        const finalTotalScore = document.getElementById('finalTotalScore');
        const totalLevelsDisplay = document.getElementById('totalLevels');
        const newGameBtn = document.getElementById('newGameBtn');
        const pointsLostDisplay = document.getElementById('pointsLost');

        // Variables du jeu
        let currentLevel = 1;
        let score = 0;
        let totalScore = 0;
        let targetPercentage = 0;
        let targetTolerance = 15;
        let isPouring = false;
        let gameActive = false;
        let currentGamma = 0;
        let gameOver = false;
        let lastBeerHeight = 0;
        const WINNING_SCORE = 1000;
        let lastPourTime = 0;
        const POUR_RATE_BASE = 0.1;
        const POUR_RATE_MULTIPLIER = 0.02;

        // Audio context et variables pour le son
        let audioContext;
        let audioBuffer;
        let sourceNode;
        let gainNode;
        let isSoundPlaying = false;
        let audioInitialized = false;
        let speechSynthesis = window.speechSynthesis;

        let currentUtterance = null;
        let proximitySound = null;
        let proximitySoundPlaying = false;
        let successSoundBuffer;

        // Fonction pour parler un texte
        function speak(text, interrupt = true) {
            if (interrupt && currentUtterance) {
                speechSynthesis.cancel();
            }

            if (text) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-EN';
                utterance.rate = 1.0;
                utterance.pitch = 1.0;

                currentUtterance = utterance;
                speechSynthesis.speak(utterance);
            }
        }

        // Fonction pour lire tout le contenu visible de la page
        function readAllVisibleText() {
            // Trouver l'Ã©cran actuellement visible
            let activeScreen = document.querySelector('.level-complete[style*="display: flex"], .level-fail[style*="display: flex"], .game-over[style*="display: flex"], .tutorial[style*="display: flex"]');

            let textToRead = "";

            if (activeScreen) {
                // Lire le contenu de l'Ã©cran actif
                const title = activeScreen.querySelector('h2');
                if (title) textToRead += title.textContent + ". ";

                const paragraphs = activeScreen.querySelectorAll('p');
                paragraphs.forEach(p => {
                    textToRead += p.textContent + ". ";
                });

                const buttons = activeScreen.querySelectorAll('button');
                buttons.forEach(btn => {
                    textToRead += "Button " + btn.textContent + ". ";
                });
            } else {
                // Lire le contenu du jeu principal
                textToRead += "Level " + document.getElementById('level').textContent + ". ";
                textToRead += "Score: " + document.getElementById('score').textContent + ". ";
                textToRead += "Goal: fill to " + document.getElementById('target').textContent + ". ";
                textToRead += "Progres: " + document.getElementById('progressBar').textContent + ". ";

                const buttons = document.querySelectorAll('.buttons-right button');
                buttons.forEach(btn => {
                    textToRead += "Button " + btn.textContent + ". ";
                });
            }

            speak(textToRead);
        }

        // Ã‰couteur pour le bouton de lecture vocale
        document.querySelector('.voice-btn').addEventListener('click', readAllVisibleText);

        // Initialiser l'audio context aprÃ¨s une interaction utilisateur
        function initAudio() {
            if (audioInitialized) return;

            try {
                console.log("Initializing audio...");
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Charger le son du verre qui se remplit
                fetch('son/sonEau.mp4')
                    .then(response => {
                        console.log("Got water sound response");
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => {
                        console.log("Decoding water sound...");
                        return audioContext.decodeAudioData(arrayBuffer);
                    })
                    .then(decodedAudio => {
                        console.log("Water sound decoded");
                        audioBuffer = decodedAudio;

                        // Charger le son de succÃ¨s
                        console.log("Fetching success sound...");
                        return fetch('son/ting.mp4');
                    })
                    .then(response => {
                        console.log("Got success sound response");
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => {
                        console.log("Decoding success sound...");
                        return audioContext.decodeAudioData(arrayBuffer);
                    })
                    .then(decodedAudio => {
                        console.log("Success sound decoded");
                        successSoundBuffer = decodedAudio;
                        audioInitialized = true;

                        console.log("Audio initialized successfully");
                        gainNode = audioContext.createGain();
                        gainNode.gain.value = 0;
                        gainNode.connect(audioContext.destination);
                    })
                    .catch(error => {
                        console.error("Erreur de chargement audio:", error);
                    });
            } catch (e) {
                console.error("Erreur d'initialisation audio:", e);
            }
        }

        // Initialiser le son de proximitÃ©
        function initProximitySound() {
            if (!audioContext) return;

            // CrÃ©er un oscillateur pour le son de proximitÃ©
            proximitySound = audioContext.createOscillator();
            proximitySound.type = 'sine';
            proximitySound.frequency.value = 440; // FrÃ©quence de base (440Hz = La)

            // CrÃ©er un gain pour contrÃ´ler le volume
            const proximityGain = audioContext.createGain();
            proximityGain.gain.value = 0;

            // Connecter les noeuds
            proximitySound.connect(proximityGain);
            proximityGain.connect(audioContext.destination);

            // DÃ©marrer l'oscillateur (mais silencieux pour l'instant)
            proximitySound.start();

            return proximityGain;
        }

        function playSuccessSound() {
            if (!audioInitialized || !audioContext || !successSoundBuffer) {
                console.log("Audio not ready to play success sound");
                return;
            }

            try {
                const successSource = audioContext.createBufferSource();
                successSource.buffer = successSoundBuffer;

                const successGain = audioContext.createGain();
                successGain.gain.value = 0.8; // Augmentez le volume si nÃ©cessaire

                successSource.connect(successGain);
                successGain.connect(audioContext.destination);

                successSource.onended = () => console.log("Success sound finished playing");
                successSource.start();
                console.log("Success sound played");
            } catch (e) {
                console.error("Error playing success sound:", e);
            }
        }

        // Mettre Ã  jour le son en fonction du niveau de remplissage
        function updateSound(currentBeerPercentage) {
            if (!audioInitialized || !audioContext || !audioBuffer || !gainNode) return;

            // Calculer la distance Ã  la cible
            const targetHeight = targetGlass.offsetHeight * (targetPercentage / 100);
            const currentHeight = targetGlass.offsetHeight * (currentBeerPercentage / 100);
            const distanceToTarget = Math.abs(currentHeight - targetHeight);
            const maxDistance = targetGlass.offsetHeight * 0.5;

            // Normaliser la distance (0 = trÃ¨s loin, 1 = trÃ¨s proche)
            const normalizedProximity = 1 - Math.min(1, distanceToTarget / maxDistance);

            // Si on est en train de verser et que le son n'est pas dÃ©jÃ  en cours
            if (isPouring && !isSoundPlaying) {
                sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = audioBuffer;
                sourceNode.loop = true;
                sourceNode.connect(gainNode);
                sourceNode.start();
                isSoundPlaying = true;
            }

            // Ajuster le volume en fonction de la proximitÃ© avec la cible
            const minVolume = 0.1;
            const maxVolume = 0.8;
            gainNode.gain.value = minVolume + (maxVolume - minVolume) * normalizedProximity;

            // Ajuster la vitesse de lecture en fonction de l'inclinaison
            if (sourceNode) {
                const minPlaybackRate = 0.8;
                const maxPlaybackRate = 1.5;
                sourceNode.playbackRate.value = minPlaybackRate + (maxPlaybackRate - minPlaybackRate) * (currentGamma / 90);
            }

            // Jouer un son d'avertissement si on est proche de la cible
            if (normalizedProximity > 0.7) {
                // Plus on est proche, plus le son est frÃ©quent
                const pulseRate = Math.floor(normalizedProximity * 10);
                const now = Date.now();

                if (now - lastPourTime > 1000 / pulseRate) {
                    playProximitySound(normalizedProximity);
                    lastPourTime = now;
                }
            }
        }

        // ArrÃªter le son
        function stopSound() {
            if (sourceNode) {
                sourceNode.stop();
                isSoundPlaying = false;
            }
            if (gainNode) {
                gainNode.gain.value = 0;
            }
        }

        // Initialiser le jeu
        function initGame() {
            currentLevel = 1;
            score = 0;
            totalScore = 0;
            updateDisplay();
            updateProgressBar();
            setupLevel();
            tutorialScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            levelCompleteScreen.style.display = 'none';
            levelFailScreen.style.display = 'none';
            setTimeout(() => {
                readScreenContent();
            }, 500);

            setInterval(() => {
                if (gameActive && parseFloat(targetBeer.style.height) > 10) {
                    createBeerBubbles(targetBeer);
                }
                if (gameActive && parseFloat(sourceBeer.style.height) > 10) {
                    createBeerBubbles(sourceBeer);
                }
            }, 1000);

            // Initialiser le son de proximitÃ©
            initProximitySound();
        }

        // CrÃ©er des bulles de biÃ¨re
        function createBeerBubbles(container) {
            const bubbleCount = Math.floor(Math.random() * 3) + 2;

            for (let i = 0; i < bubbleCount; i++) {
                const bubble = document.createElement('div');
                bubble.className = 'beer-bubble';

                const leftPos = Math.random() * 90 + 5;
                const size = Math.random() * 6 + 3;

                bubble.style.width = `${size}px`;
                bubble.style.height = `${size}px`;
                bubble.style.left = `${leftPos}%`;
                bubble.style.bottom = '0';
                bubble.style.animationDuration = `${Math.random() * 2 + 1.5}s`;
                bubble.style.animationDelay = `${Math.random() * 1.5}s`;

                container.appendChild(bubble);

                setTimeout(() => {
                    bubble.remove();
                }, 3500);
            }
        }

        // Configuration du niveau
        function setupLevel() {
            gameOver = false;
            targetPercentage = 30 + Math.floor(Math.random() * 50);
            targetDisplay.textContent = targetPercentage + '%';
            targetLimitDisplay.textContent = targetPercentage;
            updateTargetPosition();
            sourceBeer.style.height = '100%';
            targetBeer.style.height = '0%';
            sourceBottle.style.transform = 'translateX(-90%) rotate(0deg)';
            gameActive = true;
            lastBeerHeight = 0;
            lastPourTime = 0;
            stopSound();
        }

        // Mettre Ã  jour la position de la cible
        function updateTargetPosition() {
            const glassHeight = targetGlass.offsetHeight;
            const targetPosition = glassHeight * (targetPercentage / 100);
            const toleranceHeight = glassHeight * (targetTolerance / 100);

            targetLine.style.bottom = `${targetPosition}px`;
            targetRange.style.bottom = `${targetPosition - toleranceHeight / 2}px`;
            targetRange.style.height = `${toleranceHeight}px`;
        }

        // Mise Ã  jour de l'affichage
        function updateDisplay() {
            levelDisplay.textContent = currentLevel;
            scoreDisplay.textContent = score;
        }

        // Mettre Ã  jour la barre de progression
        function updateProgressBar() {
            const progress = Math.min(100, (totalScore / WINNING_SCORE) * 100);
            progressBar.style.width = `${progress}%`;
            progressBar.textContent = `${totalScore}/${WINNING_SCORE}`;
        }

        // Gestion de l'inclinaison
        function handleOrientation(event) {
            if (!gameActive || gameOver) return;

            currentGamma = event.gamma;
            updateTiltIndicator(currentGamma);

            if (currentGamma > 10 && currentGamma < 90 && parseFloat(sourceBeer.style.height) > 0) {
                if (!isPouring) {
                    isPouring = true;
                    lastPourTime = Date.now();
                    initAudio();
                }

                const bottleAngle = Math.min(60, currentGamma);
                sourceBottle.style.transform = `translateX(-90%) rotate(${bottleAngle}deg)`;

                const now = Date.now();
                const deltaTime = now - lastPourTime;
                lastPourTime = now;

                const inclinationFactor = Math.pow(currentGamma / 90, 2);
                const timeFactor = Math.min(1, deltaTime / 1000);
                const transferRate = POUR_RATE_BASE + (POUR_RATE_MULTIPLIER * inclinationFactor * timeFactor * currentGamma);

                transferBeer(transferRate);
            } else {
                if (isPouring) {
                    isPouring = false;
                    stopSound();
                }
                sourceBottle.style.transform = 'translateX(-90%) rotate(0deg)';
            }
        }

        // Mettre Ã  jour l'indicateur de tilt
        function updateTiltIndicator(gamma) {
            const tiltX = Math.min(90, Math.max(0, gamma)) / 90 * 100;
            tiltHandle.style.transform = `translate(calc(-50% + ${tiltX}px), -50%)`;
        }

        // TransfÃ©rer la biÃ¨re
        function transferBeer(rate) {
            if (gameOver) return;

            const currentSourceHeight = parseFloat(sourceBeer.style.height);
            let currentTargetHeight = parseFloat(targetBeer.style.height);

            if (currentSourceHeight <= 0) {
                isPouring = false;
                stopSound();
                return;
            }

            const adjustedRate = rate * (1 - (currentLevel * 0.00000001));
            sourceBeer.style.height = `${Math.max(0, currentSourceHeight - adjustedRate)}%`;
            currentTargetHeight = Math.min(100, currentTargetHeight + adjustedRate);

            targetBeer.style.height = `${currentTargetHeight}%`;
            updateSound(currentTargetHeight);

            // VÃ©rifier si on atteint la cible
            const glassHeight = targetGlass.offsetHeight;
            const targetHeight = glassHeight * (targetPercentage / 100);
            const currentHeight = glassHeight * (currentTargetHeight / 100);
            const tolerance = glassHeight * (targetTolerance / 100);

            // Si on est dans la zone cible et qu'on vient juste de l'atteindre
            if (Math.abs(currentHeight - targetHeight) <= tolerance / 2 &&
                Math.abs(currentHeight - targetHeight) < Math.abs(lastBeerHeight - targetHeight)) {
                playSuccessSound();
            }

            lastBeerHeight = currentHeight;

            if (Math.random() < 0.3) {
                createBeerBubbles(targetBeer);
            }

            if (currentHeight > targetHeight + tolerance) {
                gameOver = true;
                isPouring = false;
                stopSound();
                showFailScreen(currentTargetHeight);
            }
        }
        // Afficher l'Ã©cran d'Ã©chec
        function showFailScreen(finalHeight) {
            const glassHeight = targetGlass.offsetHeight;
            const targetHeight = glassHeight * (targetPercentage / 100);
            const beerHeight = glassHeight * (finalHeight / 100);
            const distance = Math.abs(beerHeight - targetHeight);

            const maxDistance = glassHeight * 0.3;
            const precision = Math.max(0, 100 - (distance / maxDistance * 100));

            const lostPoints = 100;
            totalScore = Math.max(0, totalScore - lostPoints);
            updateProgressBar();

            actualFillDisplay.textContent = finalHeight.toFixed(0);
            document.getElementById('failPrecision').textContent = precision.toFixed(0);
            pointsLostDisplay.textContent = lostPoints;
            levelFailScreen.style.display = 'flex';
            gameActive = false;
        }

        // Calculer le score
        function calculateScore(currentBeerHeight) {
            const glassHeight = targetGlass.offsetHeight;
            const targetHeight = glassHeight * (targetPercentage / 100);
            const beerHeight = glassHeight * (currentBeerHeight / 100);
            const distance = Math.abs(beerHeight - targetHeight);

            const maxDistance = glassHeight * 0.3;
            let fillPrecision = Math.max(0, 100 - (distance / maxDistance * 100));

            // Jouer le son de succÃ¨s si la prÃ©cision est suffisante
            if (fillPrecision > 10) {
                playSuccessSound();
            }

            fillPrecision = Math.min(100, fillPrecision * 1.5);
            const levelScore = Math.floor(fillPrecision * currentLevel * 1.2);

            score += levelScore;
            totalScore += levelScore;
            updateDisplay();
            updateProgressBar();

            finalScoreDisplay.textContent = levelScore;
            precisionValue.textContent = fillPrecision.toFixed(0);
            precisionFill.style.width = `${fillPrecision}%`;

            if (totalScore >= WINNING_SCORE) {
                showWinScreen();
            }
        }

        // Afficher l'Ã©cran de victoire
        function showWinScreen() {
            gameActive = false;
            stopSound();
            finalTotalScore.textContent = totalScore;
            totalLevelsDisplay.textContent = currentLevel;
            gameOverScreen.style.display = 'flex';
        }

        // Ã‰couteurs d'Ã©vÃ©nements
        validateBtn.addEventListener('click', () => {
            if (!gameActive || gameOver) return;

            isPouring = false;
            stopSound();
            const currentBeerHeight = parseFloat(targetBeer.style.height);
            const glassHeight = targetGlass.offsetHeight;
            const targetHeight = glassHeight * (targetPercentage / 100);
            const beerHeight = glassHeight * (currentBeerHeight / 100);

            if (beerHeight > targetHeight + (glassHeight * (targetTolerance / 100))) {
                gameOver = true;
                showFailScreen(currentBeerHeight);
            } else {
                calculateScore(currentBeerHeight);
                levelCompleteScreen.style.display = 'flex';
                gameActive = false;
            }
        });

        // Recommencer le niveau
        function restartLevel() {
            setupLevel();
            levelCompleteScreen.style.display = 'none';
            levelFailScreen.style.display = 'none';
        }

        // RÃ©initialiser complÃ¨tement le jeu
        function resetGame() {
            initGame();
        }

        window.addEventListener('deviceorientation', handleOrientation);
        restartBtn.addEventListener('click', restartLevel);
        resetBtn.addEventListener('click', resetGame);
        continueBtn.addEventListener('click', () => {
            currentLevel++;
            levelCompleteScreen.style.display = 'none';
            setupLevel();
        });
        retryBtn.addEventListener('click', restartLevel);
        startBtn.addEventListener('click', () => {
            tutorialScreen.style.display = 'none';
            gameActive = true;
        });
        newGameBtn.addEventListener('click', initGame);

        // Redimensionnement de la fenÃªtre
        window.addEventListener('resize', () => {
            if (gameActive) {
                updateTargetPosition();
            }
        });

        // DÃ©marrer le jeu
        initGame();

        // Fallback pour les appareils sans capteur d'orientation
        if (!window.DeviceOrientationEvent) {
            alert("DÃ©solÃ©, ce jeu nÃ©cessite un appareil avec capteur d'orientation. Veuillez utiliser un smartphone ou une tablette.");
        }

        // ContrÃ´les alternatifs pour le dÃ©veloppement sur ordinateur
        let simulatedGamma = 0;
        const maxSimulatedGamma = 60;

        document.addEventListener('keydown', (e) => {
            if (!gameActive || gameOver) return;

            if (e.key === 'ArrowRight') {
                simulatedGamma = Math.min(maxSimulatedGamma, simulatedGamma + 5);
                handleOrientation({ gamma: simulatedGamma });
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowRight') {
                simulatedGamma = 0;
                handleOrientation({ gamma: 0 });
            }
        });

        // EmpÃªcher le changement d'orientation
        function lockOrientation() {
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('portrait').catch(function (error) {
                    console.log('Orientation lock failed: ', error);
                });
            } else if (screen.lockOrientation) {
                screen.lockOrientation('portrait');
            } else if (screen.mozLockOrientation) {
                screen.mozLockOrientation('portrait');
            } else if (screen.msLockOrientation) {
                screen.msLockOrientation('portrait');
            }
        }

        // VÃ©rifier l'orientation au chargement
        function checkOrientation() {
            if (window.innerHeight < window.innerWidth) {
                document.querySelector('.landscape-warning').style.display = 'flex';
            } else {
                document.querySelector('.landscape-warning').style.display = 'none';
            }
        }

        // VÃ©rifier l'orientation lors du changement
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);

        // Initialiser le verrouillage d'orientation
        window.addEventListener('load', function () {
            checkOrientation();
            lockOrientation();
        });
    </script>

</body>

</html>